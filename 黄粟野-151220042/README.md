# 葫芦娃大作业说明

### 一、操作说明及演示
#### 1、开始
#### 按下space键则开启新的一局游戏，若按下L键，则会弹出选择框，由用户选择已有的记录文件进行记录回放。
![image](https://github.com/Constela/java-2017f-homework/blob/master/Fianl%20Project/黄粟野-151220042/screenshots/1.png)
###### 若为回放，则
![image](https://github.com/Constela/java-2017f-homework/blob/master/Fianl%20Project/黄粟野-151220042/screenshots/5.png)
#### 2、游戏进行
#### 在上一帧按下space或选择文件后，游戏会自动开始，进行到最后，即葫芦娃和爷爷均战死或蛇精等人均战死，则会切入结束界面。
![image](https://github.com/Constela/java-2017f-homework/blob/master/Fianl%20Project/黄粟野-151220042/screenshots/2.png)
#### 3、游戏结束
#### 当双方有一方的存活人数为0时，游戏结束，此时，按下space返回，若是新游戏，则按下s可以保存这一局的记录。
###### 游戏结果
![image](https://github.com/Constela/java-2017f-homework/blob/master/Fianl%20Project/黄粟野-151220042/screenshots/3.png)
###### 保存结果
![image](https://github.com/Constela/java-2017f-homework/blob/master/Fianl%20Project/黄粟野-151220042/screenshots/4.png)


### 二、代码说明
#### 1、结构
#### 1.1 生物
##### 1.1.1 所有的生物体（葫芦娃、爷爷、蛇精、蝎子精、小喽啰）均继承自Creature基类，基类中主要定义了游戏过程中所需要的各项参数，比如各个生物体用于计算交战存活概率的rank值，生物体是否存活的标志位，生物体隶属于哪一方阵营，游戏中遇到的生物体是葫芦娃还是爷爷还是别的类别等等。交战时，生物体的移动方式也由此类中的函数给出。
##### 1.1.2 其各自的派生类，主要用于加载各自生物体存活或死亡的图片，用于后续的显示。
#### 1.2 队形
##### 1.2.1 此处的队形主要是用于游戏初始化时，双方阵营对战的站位。其基类为Formation，主要摆放了参与排队的生物体的数组，并提供该数组的接口。
##### 1.2.2 其派生类为两个，即双方的开始站位，长蛇和鹤翼。
#### 1.3 战场
##### 1.3.1 Field为整个战场空间，其上有一个N*M的二维空间，空间上的每一个位置，仅可站一个生物体。游戏进行过程中的每一个状态（BEGIN，RUNNING，END，REPLAY，REPLAYEND）下，屏幕的显示内容也由该类决定。其内容包含整个游戏运行逻辑，即生物体多线程的移动，是否相遇并发生战斗，战斗结果等。
#### 1.4 记录
##### 1.4.1 space类 
##### 用于记录当前场景下，构成场景的每一个元素，即当前场景下的全部生物体及其状态。
##### 1.4.2 record类
##### 用于记录一场游戏中的全部游戏画面（每隔0.2秒记录一次当前场景下的全部元素及其状态）和该次游戏的最终游戏结果。
##### 1.4.3 recordFile类
##### 主要承担与文件之间的交互，即将新游戏结果存入文件和读取已有的游戏记录，进行replay
#### 2、主要算法
#### 2.1 多线程
##### 每一个生物体的移动，由基类Creature中run来决定。
##### 即在游戏进行的过程中，生物体按照移动算法移动到下一个位置，对该下一位位置进行判断，若有人，则调用wait进行等待，若该位置为空，则移动到改位置，然后随机sleep一段时间，再进行下一次移动。
##### 固有的移动算法则是：先前再后找敌人所在的最近位置，然后朝该方向移动一步。若水平方向上找不到，则在垂直方向上寻找，找到当前战场上离该生物体最近的对立方，然后在y轴移动一步。
##### 每次移动后判断当前是否存在战斗，即敌对双方的某两位行进到了同一个位置，然后按照概率算法决定输赢。
##### 通过线程池来为每一个生物体创建一条线程。
##### 在运行过程中，生物体此时的位置，状态，和当前游戏状态即双方剩余人数等都必须加上synchronized修饰来实现多线程的协同。
#### 2.2 回放
##### 回放主要通过1.4所描述的3个类进行实现。用space来记录场景元素，用record记录上述元素所构成的每一个场景，用file来读写文件，形成纵向的顺承关系。以二进制的方式写文件。
### 三、面向对象
#### 3.1 抽象
##### 将构成一场游戏的所有元素抽象为生物体、队形等，划分模块，实现它们的共同性质。
#### 3.2 继承
##### 上述抽象出的模块化成基类，将每一个元素由所属模块的基类继承实现，如葫芦娃，爷爷等生物继承Creature，葫芦娃和小喽啰的阵型则继承阵型的Formation基类等。
#### 3.3 封装
##### 在类的实现过程中，重要的数据会声明为private类型，由get和set函数来获取和修改，避免其他类直接操纵该类数据。
### 四、设计原则
#### 4.1 装饰模式
##### 在读写文件时，将数据先存放进缓冲流，再由缓冲流获取具体数据。
#### 4.2 单一职责原则
##### 基本上只有有一个原因引起一个类的变化。如存放场景元素的Space类，只承担记录场景元素（他们的位置，状态）等的职责，也就是说，只有场景原色的变化才会使得该类改变。而recordFile类，则只承担程序和文件交互的功能职责。
#### 4.3 状态模式
##### 整个游戏有5中状态，开始，进行，结束，回放，回放结束。状态改变的同时，行为动作也会跟随改变。
### 总结
#### 通过一整个学期的java学习，最主要的收获还是对面向对象编程认知的改变和编写面向对象程序时思路的转换。以前认为把实现过程中的物体对象写成有性质和实现函数的类就是面向对象编程了。现在想来还是太肤浅。并没有从如何通过对象及其关系来解决问题这个角度思考，也就忽略了解决问题过程中各个类之间的关系以及其关系对于解决问题的作用。两者之间是合成还是继承，如何又更利于代码稳定和复用，都是在写代码过程中很值得思考的问题。
#### 也是第一次在程序中运用多态机制，实现多线程的程序。是一种全新的体验。

